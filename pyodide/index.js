importScripts("https://cdn.jsdelivr.net/pyodide/v0.28.2/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.7.3-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.7.1/dist/wheels/panel-1.7.1-py3-none-any.whl', 'pyodide-http==0.2.1', 'lzma', 'typing-extensions', 'brightwebapp==0.0.9']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\nimport panel as pn\npn.extension(notifications=True)\npn.extension(design='material')\npn.extension('plotly')\npn.extension('tabulator')\n\nfrom brightwebapp.brightway import (\n    load_and_set_useeio_project,\n    brightway_wasm_database_storage_workaround\n)\nfrom brightwebapp.modifications import (\n    _create_user_input_columns,\n    _update_burden_intensity_based_on_user_data,\n    _update_production_based_on_user_data,\n    _update_burden_based_on_user_data,\n    _determine_edited_rows\n)\nfrom brightwebapp.traversal import perform_lca, perform_graph_traversal\nfrom brightwebapp.visualization import create_plotly_figure_piechart\nimport bw2data as bd\n\nimport pandas as pd\n\nbrightway_wasm_database_storage_workaround()\n\n\nclass panel_lca_class:\n    """\n    This class is used to store all the necessary information for the LCA calculation.\n    It provides methods to populate the database and perform Brightway LCA calculations.\n    All methods can be bound to a button click event.\n\n    Notes\n    -----\n    Why this class?  \n    Because in this Panel setup, data (dataframes, etc.) can only be stored in a class.\n    Therefore, functions bound to buttons etc., can only be methods of the class.\n\n    See Also\n    --------\n    [Update global variable through function bound with \u2018on_click\u2019](https://discourse.holoviz.org/t/update-global-variable-through-function-bound-with-on-click/)\n    """\n    brightway_wasm_database_storage_workaround()\n    def __init__(self):\n        self.db_name = 'USEEIO-1.1'\n        self.db = None\n        self.list_db_products = []\n        self.dict_db_methods = {}\n        self.list_db_methods = []\n        self.chosen_activity = ''\n        self.chosen_method = ''\n        self.chosen_method_unit = ''\n        self.chosen_amount = 0\n        self.lca = None\n        self.scope_dict = {'Scope 1': 0, 'Scope 2': 0, 'Scope 3': 0}\n        self.graph_traversal_cutoff = 0.1\n        self.graph_traversal = {}\n        self.df_graph_traversal_nodes = None\n        self.df_graph_traversal_edges = None\n        self.df_tabulator_from_traversal = None\n        self.sum_direct_burden = 0\n        self.df_tabulator = None # nota bene: gets updated automatically when cells in the tabulator are edited # https://panel.holoviz.org/reference/widgets/Tabulator.html#editors-editing\n        self.bool_user_provided_data = False\n\n\n    def reset_results(self, event):\n        """\n        Resets all results to initial state.  \n        Does not reset the database or the chosen activity/method/amount.\n        """\n        self.scope_dict = {'Scope 1': 0, 'Scope 2': 0, 'Scope 3': 0}\n        self.df_tabulator = pd.DataFrame([['']], columns=['Data will appear here after calculations...'])\n\n    def set_db(self, event):\n        """\n        Checks if the USEEIO-1.1 Brightway project is installed.\n        If not, installs it and sets is as current project.\n        Else just sets the current project to USEEIO-1.1.\n        """\n        load_and_set_useeio_project()\n        self.db = bd.Database(self.db_name)\n\n\n    def set_list_db_products(self, event):\n        """\n        Sets \`list_db_products\` to a list of product names\n        from the database for use in the autocomplete widget.\n        """\n        self.list_db_products = [node['name'] for node in self.db if 'product' in node['type']]\n    \n\n    def set_methods_objects(self, event):\n        """\n        dict_methods = {\n            'HRSP': ('Impact Potential', 'HRSP'),\n            'OZON': ('Impact Potential', 'OZON'),\n            ...\n        }\n        """\n        dict_methods = {i[-1]:[i] for i in bd.methods}\n        # hardcoded for better Pyodide performance\n        dict_methods_names = {\n            "HRSP": "Human Health - Respiratory Effects",\n            "OZON": "Ozone Depletion",\n            "HNC": "Human Health Noncancer",\n            "WATR": "Water",\n            "METL": "Metals",\n            "EUTR": "Eutrophication",\n            "HTOX": "Human Health Cancer and Noncancer",\n            "LAND": "Land",\n            "NREN": "Nonrenewable Energy",\n            "ETOX": "Freshwater Aquatic Ecotoxicity",\n            "PEST": "Pesticides",\n            "REN": "Renewable Energy",\n            "MINE": "Minerals and Metals",\n            "GCC": "Global Climate Change",\n            "ACID": "Acid Rain",\n            "HAPS": "Hazardous Air Pollutants",\n            "HC": "Human Health Cancer",\n            "SMOG": "Smog Formation",\n            "ENRG": "Energy"\n        }\n        # hardcoded for better Pyodide performance\n        dict_methods_units = {\n            "HRSP": "[kg PM2.5 eq]",\n            "OZON": "[kg O3 eq]",\n            "HNC": "[CTUh]",\n            "WATR": "[m3]",\n            "METL": "[kg]",\n            "EUTR": "[kg N eq]",\n            "HTOX": "[CTUh]",\n            "LAND": "[m2*yr]",\n            "NREN": "[MJ]",\n            "ETOX": "[CTUe]",\n            "PEST": "[kg]",\n            "REN": "[MJ]",\n            "MINE": "[kg]",\n            "GCC": "[kg CO2 eq]",\n            "ACID": "[kg SO2 eq]",\n            "HAPS": "[kg]",\n            "HC": "[CTUh]",\n            "SMOG": "[kg O3 eq]",\n            "ENRG": "[MJ]"\n        }\n        """\n        dict_methods_enriched = {\n            'HRSP': [('Impact Potential', 'HRSP'), 'Human Health - Respiratory effects', '[kg PM2.5 eq]'],\n            'OZON': [('Impact Potential', 'OZON'), 'Ozone Depletion', '[kg O3 eq]'],\n            ...\n        }\n        """\n        dict_methods_enriched = {\n            key: [dict_methods[key][0], dict_methods_names[key], dict_methods_units[key]]\n            for key in dict_methods\n        }\n\n        """\n        list_methods_for_autocomplete = [\n            ('HRSP', 'Human Health: Respiratory effects', '[kg PM2.5 eq]'),\n            ('OZON', 'Ozone Depletion', '[kg O3 eq]'),\n            ...\n        ]\n        """\n        list_methods_for_autocomplete = [(key, value[1], value[2]) for key, value in dict_methods_enriched.items()]\n\n        self.dict_db_methods = dict_methods_enriched\n        self.list_db_methods = list_methods_for_autocomplete\n\n\n    def set_chosen_activity(self, event):\n        """\n        Sets \`chosen_activity\` to the \`bw2data.backends.proxies.Activity\` object\n        of the chosen product from the autocomplete widget.\n        """\n        self.chosen_activity: Activity = bd.utils.get_node(\n            database = self.db_name,\n            name = widget_autocomplete_product.value,\n            type = 'product',\n            location = 'United States'\n        )\n\n\n    def set_chosen_method_and_unit(self, event):\n        """\n        Sets \`chosen_method\` to the (tuple) corresponding to the chosen method string\n        from the select widget.\n\n        Example:\n        --------\n        \`\`\`\n        widget_select_method.value = ('HRSP', 'Human Health: Respiratory effects', '[kg PM2.5 eq]')\n        widget_select_method.value[0] = 'HRSP'\n        dict_db_methods = {'HRSP': [('Impact Potential', 'HRSP'), 'Human Health - Respiratory effects', '[kg PM2.5 eq]']}\n        dict_db_methods['HRSP'][0] = ('Impact Potential', 'HRSP') # which is the tuple that bd.Method needs\n        \`\`\`\n        """\n        self.chosen_method = bd.Method(self.dict_db_methods[widget_select_method.value[0]][0])\n        self.chosen_method_unit = widget_select_method.value[2]\n\n\n    def set_chosen_amount(self, event):\n        """\n        Sets \`chosen_amount\` to the float value from the float input widget.\n        """\n        self.chosen_amount = widget_float_input_amount.value\n\n\n    def set_graph_traversal_cutoff(self, event):\n        """\n        Sets the \`graph_traversal_cutoff\` attribute to the float value from the float slider widget.\n        Note that the value is divided by 100 to convert from percentage to decimal.\n        """\n        self.graph_traversal_cutoff = widget_float_slider_cutoff.value / 100\n\n\n    def run_graph_traversal(self, event):\n        try:\n            self.lca = perform_lca(\n                demand={self.chosen_activity: self.chosen_amount},\n                method=self.chosen_method.name,\n            )\n        except ValueError as e:\n            pn.state.notifications.error(str(e), duration=15000)\n            return\n        try:\n            self.df_tabulator = perform_graph_traversal(\n                cutoff=self.graph_traversal_cutoff,\n                biosphere_cutoff=0.01,\n                max_calc=100,\n                return_format='dataframe',\n                lca=self.lca,\n            )\n        except ValueError as e:\n            pn.state.notifications.error(str(e), duration=15000)\n            return\n\n    def determine_scope_2(self, event):\n        """\n        Sets "Scope" to 2 for all rows where the "Name" column equals "Electricity; at consumer"\n        """\n        if self.df_tabulator is not None and 'Scope' in self.df_tabulator.columns and 'Name' in self.df_tabulator.columns:\n            self.df_tabulator.loc[self.df_tabulator['Name'] == 'Electricity; at consumer', 'Scope'] = 2\n\n\n    def set_table_filename(self, event):\n        """\n        Generates a string to be used a filename for downloading the tabulator.value DataFrame.\n\n        Returns\n        -------\n        str\n            Filename string.\n        """\n        str_filename: str = (\n            "activity='"\n            + self.chosen_activity['name'].replace(' ', '_').replace(';', '') .replace(',', '')\n            + "'_method='"\n            + '-'.join(self.chosen_method.name).replace(' ', '-')\n            + "'_cutoff=" \n            + str(self.graph_traversal_cutoff).replace('.', ',') \n            + ".csv"\n        )\n        filename_download.value = str_filename\n\n\n    def determine_scope_emissions(self, event):\n        """\n        Determines the scope 1/2/3 emissions from the graph traversal nodes dataframe.\n        """\n        dict_scope = {\n            'Scope 1': 0,\n            'Scope 2': 0,\n            'Scope 3': 0\n        }\n        \n        if self.df_tabulator is not None and 'Scope' in self.df_tabulator.columns and 'Name' in self.df_tabulator.columns:\n            dict_scope['Scope 1'] = self.df_tabulator.query('Scope == 1')['Burden(Direct)'].sum()\n            dict_scope['Scope 2'] = self.df_tabulator.query('Scope == 2')['Burden(Direct)'].sum()\n            dict_scope['Scope 3'] = self.df_tabulator['Burden(Direct)'].sum() - dict_scope['Scope 1'] - dict_scope['Scope 2']\n\n        panel_lca_class_instance.scope_dict = dict_scope\n\n\npanel_lca_class_instance = panel_lca_class()\n\n\n# COLUMN 1 ####################################################################\n\n\ndef button_action_load_database(event):\n    panel_lca_class_instance.set_db(event)\n    panel_lca_class_instance.set_list_db_products(event)\n    panel_lca_class_instance.set_methods_objects(event)\n    widget_autocomplete_product.options = panel_lca_class_instance.list_db_products\n    widget_select_method.options = panel_lca_class_instance.list_db_methods\n    widget_select_method.value = [item for item in panel_lca_class_instance.list_db_methods if 'GCC' in item[0]][0] # global warming as default value\n\n\ndef button_action_perform_lca(event):\n    panel_lca_class_instance.bool_user_provided_data = False\n    if panel_lca_class_instance.df_tabulator is not None:\n        panel_lca_class_instance.reset_results(event)\n    if widget_autocomplete_product.value == '':\n        pn.state.notifications.error('Please select a reference product first!', duration=5000)\n        return\n    else:\n        pn.state.notifications.info('Calculating LCA score...', duration=5000)\n        pass\n    panel_lca_class_instance.set_chosen_activity(event)\n    panel_lca_class_instance.set_chosen_method_and_unit(event)\n    panel_lca_class_instance.set_chosen_amount(event)\n    panel_lca_class_instance.set_graph_traversal_cutoff(event)\n    panel_lca_class_instance.run_graph_traversal(event)\n    panel_lca_class_instance.determine_scope_2(event)\n    widget_number_lca_score.format = f'{{value:,.3f}} {panel_lca_class_instance.chosen_method_unit}'\n    widget_tabulator.value = panel_lca_class_instance.df_tabulator\n    panel_lca_class_instance.df_tabulator_from_traversal = panel_lca_class_instance.df_tabulator.copy()\n    widget_number_lca_score.value = panel_lca_class_instance.lca.score\n    panel_lca_class_instance.sum_direct_burden = panel_lca_class_instance.df_tabulator['Burden(Direct)'].sum()\n    pn.state.notifications.success('Completed LCA score calculation!', duration=5000)\n    perform_scope_analysis(event)\n\n\ndef button_action_update_based_on_user_table_input(event):\n    if panel_lca_class_instance.bool_user_provided_data == True:\n        pn.state.notifications.warning('You have already provided user data. Please re-compute the LCA score to reset the table.', duration=10000)\n        return\n    if panel_lca_class_instance.df_tabulator.equals(panel_lca_class_instance.df_tabulator_from_traversal):\n        pn.state.notifications.info('No changes detected in table!', duration=5000)\n    else:\n        panel_lca_class_instance.bool_user_provided_data = True\n        pn.state.notifications.info('Updating data...', duration=5000)\n        df_with_user_input_columns = _create_user_input_columns(\n            df_original=panel_lca_class_instance.df_tabulator_from_traversal,\n            df_user_input=panel_lca_class_instance.df_tabulator\n        )\n        df_with_user_input_columns = _determine_edited_rows(df=df_with_user_input_columns)\n        df_with_user_input_columns = _update_burden_intensity_based_on_user_data(df=df_with_user_input_columns)\n        df_with_user_input_columns = _update_production_based_on_user_data(df=df_with_user_input_columns)\n        df_with_user_input_columns = _update_burden_based_on_user_data(df=df_with_user_input_columns)\n        widget_tabulator.value = df_with_user_input_columns\n        widget_number_lca_score.value = df_with_user_input_columns['Burden(Direct)'].sum() - panel_lca_class_instance.sum_direct_burden + panel_lca_class_instance.lca.score\n        pn.state.notifications.success('Completed update!', duration=5000)\n\ndef perform_scope_analysis(event):\n    pn.state.notifications.info('Performing Scope Analysis...', duration=5000)\n    panel_lca_class_instance.set_table_filename(event)\n    panel_lca_class_instance.determine_scope_emissions(event)\n    widget_plotly_figure_piechart.object = create_plotly_figure_piechart(panel_lca_class_instance.scope_dict)\n    pn.state.notifications.success('Scope Analysis Complete!', duration=5000)\n\n\nwidget_button_load_db = pn.widgets.Button( \n    name='Load USEEIO Database',\n    icon='database-plus',\n    button_type='primary',\n    sizing_mode='stretch_width'\n)\nwidget_button_load_db.on_click(button_action_load_database)\n\n\nwidget_autocomplete_product = pn.widgets.AutocompleteInput( \n    name='Reference Product/Product/Service',\n    options=[],\n    case_sensitive=False,\n    search_strategy='includes',\n    placeholder='Start typing your product name here...',\n    sizing_mode='stretch_width'\n)\n\nmarkdown_method_documentation = pn.pane.Markdown("""\nThe impact assessment methods are documented [in Table 3](https://www.nature.com/articles/s41597-022-01293-7/tables/4) of the [USEEIO release article](https://doi.org/10.1038/s41597-022-01293-7).\n""")\n\nwidget_select_method = pn.widgets.Select( \n    name='Impact Assessment Method',\n    options=[],\n    sizing_mode='stretch_width',\n)\n\nwidget_float_input_amount = pn.widgets.FloatInput( \n    name='(Monetary) Amount of Reference Product [USD]',\n    value=100,\n    step=1,\n    start=0,\n    sizing_mode='stretch_width'\n)\n\nwidget_button_lca = pn.widgets.Button( \n    name='Compute LCA Score',\n    icon='calculator',\n    button_type='primary',\n    sizing_mode='stretch_width'\n)\nwidget_button_lca.on_click(button_action_perform_lca)\n\nwidget_float_slider_cutoff = pn.widgets.EditableFloatSlider(\n    name='Graph Traversal Cut-Off [%]',\n    start=1,\n    end=50,\n    step=1,\n    value=10,\n    sizing_mode='stretch_width'\n)\n\nmarkdown_cutoff_documentation = pn.pane.Markdown("""\n[A cut-off of 10%](https://docs.brightway.dev/projects/graphtools/en/latest/content/api/bw_graph_tools/graph_traversal/new_node_each_visit/index.html) means that an upstream process is shown if it accounts for at least 10% of total impact. The lower value of 1% is chosen here for performance reasons only.\n""")\n\nwidget_button_udpate = pn.widgets.Button(\n    name='Update Data based on User Table Input',\n    icon='chart-donut-3',\n    button_type='primary',\n    sizing_mode='stretch_width'\n)\nwidget_button_udpate.on_click(button_action_update_based_on_user_table_input)\n\nwidget_number_lca_score = pn.indicators.Number(\n    name='LCA Impact Score',\n    font_size='30pt',\n    title_size='20pt',\n    value=0,\n    format='{value:,.3f}',\n    margin=0\n)\n\nwidget_plotly_figure_piechart = pn.pane.Plotly(\n    create_plotly_figure_piechart(\n        {'Scope 1': 0}\n    )\n)\n\ncol1 = pn.Column(\n    '# LCA Settings',\n    widget_button_load_db,\n    widget_autocomplete_product,\n    markdown_method_documentation,\n    widget_select_method,\n    widget_float_input_amount,\n    markdown_cutoff_documentation,\n    widget_float_slider_cutoff,\n    widget_button_lca,\n    widget_button_udpate,\n    pn.Spacer(height=10),\n    widget_number_lca_score,\n    widget_plotly_figure_piechart,\n)\n\n# COLUMN 2 ####################################################################\n\ndef highlight_tabulator_cells(tabulator_row):\n    """\n    Applies a background color to all rows where the 'Edited?' column is True.\n\n    See Also\n    --------\n    - https://stackoverflow.com/a/48306463\n    - https://discourse.holoviz.org/t/dynamic-update-of-tabulator-style\n    """\n    if tabulator_row['Edited?'] == True:\n        return ['background-color: orange'] * len(tabulator_row)\n    elif tabulator_row['Updated?'] == True:\n        return ['background-color: yellow'] * len(tabulator_row)\n    else:\n        return [''] * len(tabulator_row)\n    \n\neditors = {\n    'Name': None, # 'None' ensured that the cell is not editable\n    'UID': None,\n    'SupplyAmount': {\n        'type': 'number',\n        'step': 0.01\n    },\n    'BurdenIntensity': {\n        'type': 'number',\n        'step': 0.01\n    },\n    'Scope': {\n        'type': 'list',\n        'values': [1, 2, 3]\n    },\n    'Burden(Cumulative)': None,\n    'Burden(Direct)': None,\n    'Depth': None,\n    'Branch': None,\n}\nwidget_tabulator = pn.widgets.Tabulator(\n    pd.DataFrame([['']], columns=['Data will appear here after calculations...']),\n    editors=editors,\n    theme='site',\n    show_index=False,\n    hidden_columns=['activity_datapackage_id', 'producer_unique_id', 'Edited?', 'Updated?'],\n    layout='fit_data_stretch',\n    sizing_mode='stretch_width'\n)\nwidget_tabulator.style.apply(highlight_tabulator_cells, axis=1)\n\nfilename_download, button_download = widget_tabulator.download_menu(\n    text_kwargs={'name': 'Filename', 'value': 'filename.csv'},\n    button_kwargs={'name': 'Download Table'}\n)\nfilename_download.sizing_mode = 'stretch_width'\nbutton_download.align = 'center'\nbutton_download.icon = 'download'\n\nwidget_cutoff_indicator_statictext = pn.widgets.StaticText(\n    name='Includes processes responsible for amount of emissions [%]',\n    value=None\n)\n\ncol2 = pn.Column(\n    pn.Row('# Table of Upstream Processes', filename_download, button_download),\n    widget_tabulator\n)\n\n# SITE ######################################################################\n\ncode_open_window = """\nwindow.open("https://brightwebapp.readthedocs.io/")\n"""\nbutton_about = pn.widgets.Button(name="Learn more about this web application...", button_type="success")\nbutton_about.js_on_click(code=code_open_window)\n\nheader = pn.Row(\n    button_about,\n    pn.HSpacer(),\n    pn.pane.SVG(\n        'https://raw.githubusercontent.com/brightway-lca/brightway-webapp/main/app/_media/logo_PSI-ETHZ-WISER_white.svg',\n        #height=50,\n        margin=0,\n        align="center"\n    ),\n    sizing_mode="stretch_width",\n)\n\ntemplate = pn.template.MaterialTemplate(\n    header=header,\n    title='BrightWebApp (Carbon Accounting)',\n    header_background='#2d853a', # green\n    logo='https://raw.githubusercontent.com/brightway-lca/brightway-webapp/main/docs/_logos/brightwebapp_logo.svg',\n    favicon='https://raw.githubusercontent.com/brightway-lca/brightway-webapp/main/docs/_logos/brightwebapp_logo.svg',\n)\n\ngspec = pn.GridSpec(ncols=3, sizing_mode='stretch_both')\ngspec[:,0:1] = col1 # 1/3rd of the width\ngspec[:,1:3] = col2 # 2/3rds of the width\n\ntemplate.main.append(gspec)\ntemplate.servable()\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()